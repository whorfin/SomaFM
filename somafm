#!/usr/bin/env python3
# Python frontend for playing SomaFM with MPlayer
# Written by Tom Nardi (MS3FGX@gmail.com)
# Licensed under the GPLv3, see "COPYING"
#   customized and extended with a focus on mpv by whorfin
version = "1.82-whorfin"

import re
import os
import sys
import signal
import requests
import argparse
import colorama
import platform
import subprocess
from random import randrange, choice
from datetime import datetime
from colorama import Fore, Style

# Optional Chromecast support, don't error if can't import
try:
    import pychromecast
    chromecast_support = True
except ImportError:
    chromecast_support = False

# Basic config options:
#-----------------------------------------------------------------------

# Default channel to play
default_chan = "Drone Zone"

# Name of Chromecast device
chromecast_name = "The Office"

# Show track names in terminal while casting
cast_sync = True

# Highlight station IDs in yellow
station_highlights = True

# Experimental Options:
#-----------------------------------------------------------------------

# Run a custom command on each new track (BE CAREFUL)
custom_notifications = False

# Custom notification command, track title will be given as argument
notification_cmd = ""

# Log tracks to file
log_tracks = False

# File to store track listing
track_file = "/tmp/somafm_tracks.txt"

# Following variables should probably be left alone
#-----------------------------------------------------------------------

# SomaFM channel list
url = "https://somafm.com/channels.json"

# Default image size for icons
image_size = "xlimage"

# Known station IDs
station_ids = ["SomaFM", "Big Url", "Nerd Show"]

# Define functions
#-----------------------------------------------------------------------#
# Catch ctrl-c
def signal_handler(sig, frame):
    # Re-enable cursor if it was turned off
    print('\033[?25h')
    print(Fore.RED + "Force closing...")
    clean_exit()

# Do any necessary cleanup when closing on good terms
def clean_exit():
    playstream.terminate()  # just in case, and especially w/ audio error loop
    sys.exit(0)

# Download master list of channels
def downloadChannels():
    # Make global so other functions can acess it
    global channel_list

    # Let user know we're downloading
    print("Downloading channel list...", end='')
    sys.stdout.flush()

    # Pull down JSON file
    try:
        channel_raw = requests.get(url, timeout=15)
    except requests.exceptions.Timeout:
        print("Timeout!")
        clean_exit()
    except requests.exceptions.ConnectionError:
        print("Network Error!")
        clean_exit()
    except requests.exceptions.RequestException as e:
        print("Unknown Error!")
        clean_exit()

    # Put channels in list
    channel_list = channel_raw.json()['channels']

    # sort it
    channel_list.sort(key=lambda x: x['id'].lower())

    print("OK")

# Loop through channels and print their descriptions
def listChannels():

    # Find longest channel name
    channel_length = max(len(channel['title']) for channel in channel_list)

    # Loop through channels
    print(Fore.RED + "------------------------------")
    for channel in channel_list:
        # Adjust spacing to fit longest channel name
        print(Fore.BLUE + '{cname:>{cwidth}}'.format(cwidth=channel_length, cname=channel['title']) + Fore.WHITE, end=' : ')
        print(Fore.GREEN + channel['description'] + Fore.RESET)

# Show sorted list of listeners
def showStats():
    # To count total listeners
    listeners = 0

    # mini list for listener sorting
    listener_list = []

    # Put channels and listener counts into list
    for channel in channel_list:
        listener_list.append([channel['title'], int(channel['listeners'])])

    # Sort and print results
    listener_list.sort(key=lambda x: x[1], reverse=True)
    print(Fore.RED + "------------------------------")
    for key, val in listener_list:
        # Total up listeners
        listeners = listeners + val
        print(Fore.GREEN + '{:>4}'.format(val) + Fore.BLUE, end=' : ')
        print(Fore.BLUE + key + Fore.RESET)

    # Print total line
    print(Fore.YELLOW + '{:>4}'.format(listeners) + Fore.BLUE, end=' : ')
    print(Fore.CYAN + "Total Listeners" + Fore.RESET)

# Return information for given channel
def channelGet(request, channel_name):
    for channel in channel_list:
        if channel_name.lower() in channel['title'].lower():
            # Channel exists, now what?
            if request == "VERIFY":
                return()
            elif request == "PLS":
                # the first one isn't necessarily the best; "quality_num" was just the nth, 
                # but they have names! and aren't necessarily ordered by quality; mp3 comes 
                # before aac now
                #   we want "highest" and 'aac' if we can get it [should always be true]
                #return(channel['playlists'][0]['url'])

                #print(channel['playlists'])
                url = None
                fmt = None
                for pls in channel['playlists']:
                    #print(pls)
                    if pls['quality'] == "highest":
                        url = pls['url']
                        fmt = pls['format']
                        if fmt == "aac":
                            return(pls['url'])
                if url != None:
                    print(Fore.RED + "Could not find AAC stream, settling for " + fmt + Fore.WHITE)
                    return(url)
                print(Fore.RED + "No 'highest' quality stream found, bailing")
                clean_exit()
            elif request == "NAME":
                return(channel['title'])
            elif request == "DESC":
                return(channel['description'])
            elif request == "ICON_URL":
                return(channel[image_size])
            elif request == "URL":
                # Download PLS
                url = channelGet("PLS", channel_name)
                pls_file = requests.get(url)

                # Split out file URL
                for line in pls_file.text.splitlines():
                    if "File1" in line:
                        return(line.split('=')[1])
            else:
                print(Fore.RED + "Unknown channel operation!")
                clean_exit()

    # If we get here, no match
    print(Fore.RED + "Channel not found!")
    print(Fore.WHITE + "Double check the name of the channel and try again.")
    clean_exit()

# Stream channel with media player
def startStream(channel_name):
    # Verify stream exists before starting stream
    stream_link = channelGet('PLS', args.channel)   # mpv wants PLS

    # Open stream
    print("Loading stream...", end='')

    psa = ['mpv']
    # since we are using playlists, loop over the playlist to handle server oopses
    # or network issues; "force" re-evaluates each entry for validity each time 
    # through rather than caching the [possibly temporary] busted status
    #
    # The caching stuff here looks a little weird but ensures a 4s buffer
    #   somafm allows fast download of approx 8 seconds, then it is "realtime"
    #   (so we debugged with a 10sec cache setting)
    # Adding "--demuxer-cache-wait=yes" won't start until cache is full (and is 
    #   supposed to have no further influence during runtime), otherwise
    #   this combo of flags (which oddly requires cache-pause-initial though it 
    #   doesn't wait) will set things up to maintain a 4 second cache, reading
    #   more if needed even while playing
    cacheSecs = 4
    psa += ['--no-video',
            '--loop-playlist=force',
            '--cache=yes',
            '--cache-secs={}'.format(cacheSecs),
                # these settings only change start behavior it seems
                #
                #'--cache-pause-wait={}'.format(cacheSecs),
                #'--cache-pause=yes',
                #'--cache-pause-initial=yes',
            # dump icy- metadata and codec info when starting
            #   ${playlist} shows playlist contents [with carriage returns, along with which is active], ${media-title} is name of playlist
            '--term-playing-msg=PLS: ${media-title}\n${metadata}\nCodec: ${audio-codec}'
            ]
    psa += ['--network-timeout=30']
    # default of alsa/pipewire fixes glitches and ticks compared to pulse pipewire in some scenarios
    psa += ["--audio-device="+args.audio]
    psa.append(stream_link)

    global playstream
    try:
        playstream = subprocess.Popen(psa,
                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=False)
    except:
        print(Fore.RED + "FAILED")
        print("")
        print(Fore.WHITE + "Playback encountered an unknown error.")
        clean_exit()
    print("OK")

    # Hand off to info display
    streamInfo(playstream)

# Stream channel on Chromecast
def startCast(channel_name):
    # Populate stream variables
    stream_name = channelGet('NAME', channel_name)
    stream_url = channelGet('URL', channel_name)

    # Now try to communicate with CC
    print("Connecting to", chromecast_name, end='...')
    sys.stdout.flush()
    try:
        chromecasts = pychromecast.get_chromecasts()
        cast = next(cc for cc in chromecasts if cc.device.friendly_name == chromecast_name)
    except:
        print(Fore.RED + "FAILED")
        print("")
        print(Fore.WHITE + "Double check the device name and try again.")
        clean_exit()

    # Attempt to start stream
    try:
        cast.wait()
        stream = cast.media_controller
        stream.play_media(stream_url, 'audio/mp3', stream_name, channelGet('ICON_URL', channel_name))
        stream.block_until_active()
    except:
        print(Fore.RED + "FAILED")
        print("")
        print(Fore.WHITE + "Stream failed to start on Chromecast.")
        clean_exit()
    print("OK")

    # Start player with no audio to get track info
    if cast_sync:
        # Playing without audio doesn't seem to work in mpv, so bail out for now
        #   which is fine since i haven't tested mpv with chromecast
        print(Fore.RED + "Cast sync not supported on mpv.")
        clean_exit()

        global playstream
        try:
            # whorfin: sarg1/2 aren't there any more, this will fail; fix up if i ever care about chromecast
            playstream = subprocess.Popen(['mpv', player['sarg1'], player['sarg2'], stream_url],
                         stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=False)
        except:
            print(Fore.RED + "Track Sync Failed!")
            clean_exit()

        # Hand off to info display
        streamInfo(playstream)

        # If we get here, then player has stopped and so should Cast
        cast.quit_app()
    else:
        print(Fore.RED + "--------------------------")
        print(Fore.WHITE + "Now playing: " + Fore.CYAN + stream_name)
        clean_exit()

# Determine if track is a Station ID
def stationID(track):
    # Loop through known IDs, return on match
    for station in station_ids:
        if station.upper() in track.upper():
            return(True)

    # If we get here, no match was found
    return(False)

# Print stream and track information
def streamInfo(playstream):
    # Hide cursor
    print('\033[?25l', end="")

    InfoPrinted = False
    print(Fore.RED + "--------------------------")
    # Parse output
    for line in playstream.stdout:
        # Print debug information
        if args.verbose:
            print(line)

        # Printed at start, and when we loop through playlist because of server or network failure
        if line.startswith(b'Playing'):
            print(Fore.CYAN + "Stream Server: " + Fore.WHITE + line.decode().split(':', 1)[1].strip())

        if InfoPrinted is False:
            if line.startswith(b'icy-br'):
                print(Fore.CYAN + "Bitrate: " + Fore.WHITE + line.decode().split(':', 1)[1].strip())
            if line.startswith(b'icy-name'):
                print(Fore.CYAN + "Channel: " + Fore.WHITE + line.decode().split(':', 1)[1].strip())
            if line.startswith(b'icy-genre'):
                print(Fore.CYAN + "Genre: " + Fore.WHITE + line.decode().split(':', 1)[1].strip())
            if line.startswith(b'Codec'):
                print(Fore.CYAN + "Codec: " + Fore.WHITE + line.decode().split(':', 1)[1].strip())
            if line.startswith(b'PLS'):
                print(Fore.CYAN + "Playlist: " + Fore.WHITE + line.decode().split(':', 1)[1].strip())

            if line.startswith(b'File tags:'):
                print(Fore.RED + "--------------------------")
                print(Fore.WHITE + "Press Crtl+C to Quit", end="")
                InfoPrinted = True

        # Updates on every new track
        if line.startswith(b'ICY Info:') or line.startswith(b'ICY-META:') or line.startswith(b' icy-title:'):
            if line.startswith(b' icy-title:'):
                track = line.decode().split(':', 1)[1].strip()

            # Print date before track
            print("")
            print(Fore.BLUE + datetime.now().strftime("%H:%M:%S"), end=' | ')

            # Check if track is a station ID once, save value to variable
            IDStatus = stationID(track)

            # Highlight station IDs in yellow
            if station_highlights and IDStatus:
                print(Fore.YELLOW + track, end="")
            else:
                print(Fore.GREEN + track, end="")

            # Flush line so far
            sys.stdout.flush()

            # Before doing anything further, make sure it's not a Station ID
            if not IDStatus:
                # Log track to file if enabled
                if log_tracks:
                    track_log.write(track + "\n")

                # Run custom notification command if enabled
                if custom_notifications:
                    subprocess.run([notification_cmd, track], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=False)

        # because we are looping the playlist, mpv unfortunately doesn't quit if we gave it
        # a bad audio device, we have to detect this
        if line.startswith(b'[ao] Failed to initialize audio driver'):
            print(Fore.RED + "ERROR: failed to initialize audio drive " + args.audio)
            clean_exit()

# Execution below this line
#-----------------------------------------------------------------------#
# Load signal handler
signal.signal(signal.SIGINT, signal_handler)

# Handle arguments
parser = argparse.ArgumentParser(description='Simple Python 3 player for SomaFM, version ' + version)
parser.add_argument('-l', '--list', action='store_true', help='Download and display list of channels')
parser.add_argument('-s', '--stats', action='store_true', help='Display current listener stats')
parser.add_argument('-a', '--about', action='store_true', help='Show information about SomaFM')
parser.add_argument('-c', '--cast', nargs='?', default=False, help='Start playback on Chromecast')
parser.add_argument('-f', '--file', action='store_true', help='Enable experimental track logging for this session')
parser.add_argument('-v', '--verbose', action='store_true', help='For debug use, prints all output of media player.')
parser.add_argument('-r', '--random', action='store_true', help='Choose a random channel at startup')
parser.add_argument('-ao', '--audio', nargs='?', metavar='audio-device', default='alsa/pipewire', help='Audio device to use [default alsa/pipewire], use "help" to list available devices')
parser.add_argument("channel", nargs='?', const=1, default=None, help="Channel to stream. Default is Drone Zone (unless the --random flag is passed)")
args = parser.parse_args()

# None means user gave -c option, but no device name
if args.cast is None:
    args.cast = True
else:
    # If there is string after -c, use it as device name
    chromecast_name = args.cast

# Enable log file
if args.file:
    log_tracks = True

# check if we were trying to list audio devices
if args.audio == "help":
    devices = subprocess.run(['mpv', '--audio-device=help'], stdout=subprocess.PIPE).stdout.decode('utf-8')
    print(devices)
    clean_exit()

# Get screen ready
colorama.init()
if platform.system() == "Windows":
    os.system('cls')
else:
    os.system('clear')
print(Style.BRIGHT, end='')

if args.about:
    # I can't decide which one I like best, so let's use them all!
    randlogo = randrange(3)
    if randlogo == 0:
        print(Fore.BLUE + r"   _____                  " + Fore.GREEN + r"     ________  ___")
        print(Fore.BLUE + r"  / ___/____  ____ ___  ____ _" + Fore.GREEN + r"/ ____/  |/  /")
        print(Fore.BLUE + r"  \__ \/ __ \/ __ `__ \/ __ `" + Fore.GREEN + r"/ /_  / /|_/ / ")
        print(Fore.BLUE + r" ___/ / /_/ / / / / / / /_/ " + Fore.GREEN + r"/ __/ / /  / /  ")
        print(Fore.BLUE + r"/____/\____/_/ /_/ /_/\__,_" + Fore.GREEN + r"/_/   /_/  /_/   ")
    elif randlogo == 1:
        print(Fore.BLUE + r" __" + Fore.GREEN + r"                         ___")
        print(Fore.BLUE + r"/ _\ ___  _ __ ___   __ _  " + Fore.GREEN + r"/ __\/\/\   ")
        print(Fore.BLUE + r"\ \ / _ \| '_ ` _ \ / _` |" + Fore.GREEN + r"/ _\ /    \  ")
        print(Fore.BLUE + r"_\ \ (_) | | | | | | (_| " + Fore.GREEN + r"/ /  / /\/\ \ ")
        print(Fore.BLUE + r"\__/\___/|_| |_| |_|\__,_" + Fore.GREEN + r"\/   \/    \/ ")
    elif randlogo == 2:
        print(Fore.BLUE + r" ______     ______     __    __     ______  " + Fore.GREEN + r"   ______   __    __    ")
        print(Fore.BLUE + r"/\  ___\   /\  __ \   /\ '-./  \   /\  __ \ " + Fore.GREEN + r"  /\  ___\ /\ '-./  \   ")
        print(Fore.BLUE + r"\ \___  \  \ \ \/\ \  \ \ \-./\ \  \ \  __ \ " + Fore.GREEN + r" \ \  __\ \ \ \-./\ \  ")
        print(Fore.BLUE + r" \/\_____\  \ \_____\  \ \_\ \ \_\  \ \_\ \_\ " + Fore.GREEN + r" \ \_\    \ \_\ \ \_\ ")
        print(Fore.BLUE + r"  \/_____/   \/_____/   \/_/  \/_/   \/_/\/_/ " + Fore.GREEN + r"  \/_/     \/_/  \/_/ ")

    print(Fore.WHITE + "")
    print("SomaFM is a listener-supported Internet-only radio station.")
    print("")
    print("That means no advertising or annoying commercial interruptions. SomaFM's")
    print("mission is to search for and expose great new music which people may")
    print("otherwise never encounter.")
    print("")
    print("If you like what you hear on SomaFM and want to help, please consider")
    print("visiting their site and making a donation.")
    print("")
    print(Fore.BLUE + "https://somafm.com/support/")
    print("")
    clean_exit()

# declare the device
print("Using audio device: " + args.audio)

# get channel list
downloadChannels()

if args.list:
    listChannels()
    clean_exit()

if args.stats:
    showStats()
    clean_exit()

# Open file for track logging (enable line buffering)
if log_tracks:
    track_log = open(track_file, 'a', 1)

# If -r option given and no channel provided, pick random channel from list
if args.random and args.channel == None:
    args.channel = choice([chan['title'] for chan in channel_list])
elif args.channel == None:
    args.channel = default_chan

# Record the start time
start_time = datetime.now()

# If Chromecast support is enabled, break off here
if args.cast:
    if chromecast_support:
        startCast(args.channel)
    else:
        print(Fore.RED + "Chromecast Support Disabled!")
        print(Fore.WHITE + "Please install the pychromecast library.")
        clean_exit()
else:
    # Else, start stream
    startStream(args.channel)

# Calculate how long we were playing
time_elapsed = datetime.now() - start_time
hours, remainder = divmod(int(time_elapsed.total_seconds()), 3600)
minutes, seconds = divmod(remainder, 60)

# Close log file
if log_tracks:
    track_log.close()

# Print exit message
print('\033[?25h')
print(Fore.RESET + "Playback stopped after {:02}:{:02}:{:02}".format(int(hours), int(minutes), int(seconds)))

# EOF
