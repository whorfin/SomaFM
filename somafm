#!/usr/bin/env python3
# Python frontend for playing SomaFM with mpv
# Written by Tom Nardi (MS3FGX@gmail.com)
# Licensed under the GPLv3, see "COPYING"
#   customized and extended with a focus on mpv by whorfin
version = "2.1"

import re
import os
import sys
import socket
import signal
import requests
import argparse
import colorama
import subprocess
import time
from random import randrange, choice
from datetime import datetime
from colorama import Fore, Style

from threading import Thread, Lock
import tty,termios   # sys and os already imported
import uuid
import json

from enum import Enum

# Optional Chromecast support, don't error if can't import
try:
    import pychromecast
    chromecast_support = True
except ImportError:
    chromecast_support = False

# Basic config options:
#-----------------------------------------------------------------------

# Default channel to play
default_chan = "Drone Zone"

# Name of Chromecast device
chromecast_name = "The Sound Pool"

# Experimental Options:
#-----------------------------------------------------------------------

# Run a custom command on each new track (BE CAREFUL)
custom_notifications = False

# Custom notification command, track title will be given as argument
notification_cmd = ""

# Log tracks to file
log_tracks = False

# File to store track listing
track_file = "/tmp/somafm_tracks.txt"

# Following variables should probably be left alone
#-----------------------------------------------------------------------

# SomaFM channel list
channelsURL = "https://somafm.com/channels.json"

# Default image size for icons
image_size = "xlimage"

## set up needed globals
sock = None

# create the locks we will need
socketLock = Lock()     # protect against thread races in socket usage

# we will need to manually launch player, and can watch it
# mpv --no-video --keep-open=no --audio-device=alsa/pipewire --input-ipc-server=/tmp/mpvsocket --idle
debugPlayer = False

# socket to use
if debugPlayer:
    udsock = "/tmp/mpvsocket"
else:
    udsock = f"/tmp/mpvsocket.{uuid.uuid1()}"

# global process handle
playstream = None
# global cast and stream handles if active
cast = None
stream = None

# enums to keep track of requests
class mpvRequestID(Enum):
    TRACK = 1
    PLAYLIST = 2
    METADATA = 3
    CODEC = 4
    PARAMS = 5
    BITRATE = 6

def createUDS(udsock):
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    print(f'Connecting to {udsock}...', end="")
    sys.stdout.flush()
    # wait until mpv starts
    connected = False
    while not connected:
        try:
            sock.connect(udsock)
            connected = True
        except:
            time.sleep(.1)
    print("")
    return(sock)

# cmds is a list
def sockSendCmds(cmds, request_id=None):
    # since we send this via JSON, mpv's input/ipc.c tells us we have to be careful to create
    #   valid json.  So let's use the real json parser to handle escaping
    #
    # build the json for the list of cmds
    jcmds = {"command": cmds}
    if request_id is not None:
        jcmds.update({"request_id": request_id})

    # serialize and transmit
    strcmds = json.dumps(jcmds)
    with socketLock:
        sock.sendall(f'{strcmds}\n'.encode('utf-8'))

# if we send tracks with "append-play", first track's force-media-title may not work
#   so once we've got the playlist set, we need to start playback
def sendPlaybackURL(url):
    sockSendCmds(["loadfile", url, "append"])

def startPlay():
    sockSendCmds(["playlist-play-index", 0])

def print_stop_time():
    # Calculate how long we were playing
    time_elapsed = datetime.now() - start_time
    hours, remainder = divmod(int(time_elapsed.total_seconds()), 3600)
    minutes, seconds = divmod(remainder, 60)

    # Print exit message
    print('\033[?25h')
    print(Fore.RESET + "Playback stopped after {:02}:{:02}:{:02}".format(int(hours), int(minutes), int(seconds)))

# Catch ctrl-c
def signal_handler(sig, frame):
    # Re-enable cursor if it was turned off
    print('\033[?25h')
    print(Fore.RED + "Force closing...")
    print_stop_time()
    clean_exit()

# Do any necessary cleanup when closing on good terms
termSettings = termios.tcgetattr(sys.stdin)
def clean_exit():
    # Re-enable cursor if it was turned off
    print('\033[?25h')

    global sock
    if sock is not None:
        sockSendCmds(["quit"])
        sock = None
    global playstream
    if (playstream is not None):
        playstream.terminate()  # just in case, and especially w/ audio error loop
        playstream = None
    global stream
    if (stream is not None):
        # stop playback and shut down cast app, back to ambient mode if enabled
        stream.stop()
        cast.quit_app()
    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, termSettings)
    try:
        os.unlink(udsock)
    except OSError:
        pass

    # Close log file
    if log_tracks:
        track_log.close()
    sys.exit(0)

# Download master list of channels
def downloadChannels():
    # Make global so other functions can access it
    global channel_list

    # Let user know we're downloading
    print("Downloading channel list...", end='')
    sys.stdout.flush()

    # Pull down JSON file
    try:
        channel_raw = requests.get(channelsURL, timeout=15)
    except requests.exceptions.Timeout:
        print("Timeout!")
        clean_exit()
    except requests.exceptions.ConnectionError:
        print("Network Error!")
        clean_exit()
    except requests.exceptions.RequestException as e:
        print("Unknown Error!")
        clean_exit()

    # Put channels in list
    channel_list = channel_raw.json()['channels']

    # sort it
    channel_list.sort(key=lambda x: x['id'].lower())

    print("OK")

# Loop through channels and print their descriptions
def listChannels():

    # Find longest channel name
    channel_length = max(len(channel['title']) for channel in channel_list)

    # Loop through channels
    print(Fore.RED + "------------------------------")
    for channel in channel_list:
        # Adjust spacing to fit longest channel name
        print(Fore.BLUE + '{cname:>{cwidth}}'.format(cwidth=channel_length, cname=channel['title']) + Fore.WHITE, end=' : ')
        print(Fore.GREEN + channel['description'] + Fore.RESET)

# Show sorted list of listeners
def showStats():
    # To count total listeners
    listeners = 0

    # mini list for listener sorting
    listener_list = []

    # Put channels and listener counts into list
    for channel in channel_list:
        listener_list.append([channel['title'], int(channel['listeners'])])

    # Sort and print results
    listener_list.sort(key=lambda x: x[1], reverse=True)
    print(Fore.RED + "------------------------------")
    for key, val in listener_list:
        # Total up listeners
        listeners = listeners + val
        print(Fore.GREEN + '{:>4}'.format(val) + Fore.BLUE, end=' : ')
        print(Fore.BLUE + key + Fore.RESET)

    # Print total line
    print(Fore.YELLOW + '{:>4}'.format(listeners) + Fore.BLUE, end=' : ')
    print(Fore.CYAN + "Total Listeners" + Fore.RESET)

# Return information for given channel
def channelGet(request, channel_name):
    for channel in channel_list:
        if channel_name.lower() in channel['title'].lower():
            # Channel exists, now what?
            if request == "VERIFY":
                return()
            elif request == "PLS":
                # the first one isn't necessarily the best; "quality_num" was just the nth, 
                # but they have names! and aren't necessarily ordered by quality; mp3 comes 
                # before aac now
                #   we want "highest" and 'aac' if we can get it [should always be true]
                #return(channel['playlists'][0]['url'])

                #print(channel['playlists'])
                url = None
                fmt = None
                if "hlsPlaylists" in channel:
                    for pls in channel['hlsPlaylists']:
                        #print(pls)
                        if pls['quality'] == "lossless":
                            url = pls['url']
                            fmt = pls['format']
                            if fmt == "flac-fmp4":
                                print(f"{Fore.GREEN}Good news, everybody!  Lossless stream found.{Fore.WHITE}")
                                return(pls['url'])
                for pls in channel['playlists']:
                    #print(pls)
                    if pls['quality'] == "highest":
                        url = pls['url']
                        fmt = pls['format']
                        if fmt == "aac":
                            return(pls['url'])
                if url != None:
                    print(f"{Fore.RED}Could not find AAC stream, settling for {fmt}{Fore.WHITE}")
                    return(url)
                print(f"{Fore.RED}No 'highest' quality stream found, bailing{Fore.WHITE}")
                clean_exit()
            elif request == "NAME":
                return(channel['title'])
            elif request == "DESC":
                return(channel['description'])
            elif request == "ICON_URL":
                return(channel[image_size])
            elif request == "STID":
                return(channel['id'])
            elif request == "URL":
                # parse this out directly, we only want one format; AAC FTW
                url = None
                fmt = None
                for pls in channel['playlists']:
                    #print(pls)
                    if pls['quality'] == "highest":
                        fmt = pls['format']
                        if fmt == "aac":
                            url = pls['url']
                            break
                if url == None:
                    print(Fore.RED + "No 'highest' quality AAC stream found, bailing")
                    clean_exit()

                pls_file = requests.get(url)
                # Split out file URL
                for line in pls_file.text.splitlines():
                    if "File1" in line:
                        return(line.split('=')[1])
            else:
                print(Fore.RED + "Unknown channel operation!")
                clean_exit()

    # If we get here, no match
    print(Fore.RED + "Channel not found!")
    print(Fore.WHITE + "Double check the name of the channel and try again.")
    clean_exit()

# Stream channel with media player
def startStream(channel_name):
    # Verify stream exists before starting stream
    stream_link = channelGet('PLS', args.channel)   # mpv wants PLS

    # launch mpv
    if not debugPlayer:
        # since we are using playlists, loop over the playlist to handle server oopses
        # or network issues; "force" re-evaluates each entry for validity each time 
        # through rather than caching the [possibly temporary] busted status
        #
        # The caching stuff here looks a little weird but ensures a 4s buffer
        #   somafm allows fast download of approx 8 seconds, then it is "realtime"
        #   (so we debugged with a 10sec cache setting)
        # Adding "--demuxer-cache-wait=yes" won't start until cache is full (and is 
        #   supposed to have no further influence during runtime), otherwise
        #   this combo of flags (which oddly requires cache-pause-initial though it 
        #   doesn't wait) will set things up to maintain a 4 second cache, reading
        #   more if needed even while playing
        cacheSecs = 4
        psa = ['mpv']
        psa += ['--no-video',
                # '--no-config',        # doing this causes global plugins such as mpv-mpris to be skipped, which we do not want
                '--keep-open=no',       # commonly overridden
                '--loop-playlist=force',
                '--cache=yes',
                f'--cache-secs={cacheSecs}'
                ]
        psa += ['--network-timeout=30']
        # default of alsa/pipewire fixes glitches and ticks compared to pulse pipewire in some scenarios
        psa += ["--audio-device="+args.audio]

        # don't output playing timecode; further reduces compute on player
        psa += ["--quiet"]
        psa += [f"--input-ipc-server={udsock}"]
        psa += ["--idle"]

        global playstream
        try:
            playstream = subprocess.Popen(psa,
                        stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                        shell=False)
        except:
            print(Fore.RED + "FAILED")
            print("")
            print(Fore.WHITE + "Playback encountered an unknown error.")
            clean_exit()
        print("Launched mpv")

    global sock
    sock = createUDS(udsock)

    print(Fore.RED + "----------------------------------------------------------------------")
    print(Fore.WHITE+"<Up> to Love a Track, <Down> to WTF?! a Track")
    print(Fore.WHITE+"<q> to Quit")
    print(Fore.RED + "----------------------------------------------------------------------")

    # send the URL and start
    sendPlaybackURL(stream_link)
    startPlay()


def getPlayingTrack():
    stid = channelGet('STID', args.channel)
    songsr = requests.get(f"https://api.somafm.com/ios/songs/{stid}.json")
    songs = songsr.json()
    track = songs["songs"][0]
    return(track)

def sendTrackLove(track):
    stid = channelGet('STID', args.channel)

    rateRaw = requests.get(f"https://api.somafm.com/ios/songlove.cgi?channel={stid}&artist={track['artist']}&title={track['title']}&device=(null)&lang=en-US")
    # rateRaw.text should be 'OK\n'

def sendTrackWTF(track):
    stid = channelGet('STID', args.channel)

    rateRaw = requests.get(f"https://api.somafm.com/ios/songwtf.cgi?channel={stid}&artist={track['artist']}&title={track['title']}&device=(null)&lang=en-US")
    # rateRaw.text should be 'OK\n'


# Stream channel on Chromecast
def startCast(channel_name):
    # Populate stream variables
    stream_name = channelGet('NAME', channel_name)
    stream_url = channelGet('URL', channel_name)
    icon_url = channelGet('ICON_URL', channel_name)

    # Now try to communicate with CC
    print("Connecting to", chromecast_name, end='...')
    sys.stdout.flush()
    chromecasts, browser = pychromecast.get_listed_chromecasts(friendly_names=[chromecast_name])
    if not chromecasts:
        print(Fore.RED + "FAILED")
        print("")
        print(Fore.WHITE + f'No chromecast with name "{chromecast_name}" discovered')
        clean_exit()
    global cast
    cast = chromecasts[0]

    # Attempt to start stream
    global stream
    try:
        # Start socket client's worker thread and wait for initial status update
        cast.wait()
        stream = cast.media_controller
        stream.play_media(stream_url, 'audio/aac', stream_name, icon_url)
        stream.block_until_active()
    except:
        print(Fore.RED + "FAILED")
        print("")
        print(Fore.WHITE + "Stream failed to start on Chromecast.")
        clean_exit()
    print("OK")

    browser.stop_discovery()

    # Start player with no audio to get track info
    psa = ['mpv']
    psa += ['--no-video']
    psa += ['--network-timeout=30']
    psa += ["--audio-device=null"]  # no audio

    # don't output playing timecode; further reduces compute for parsing
    psa += ["--quiet"]

    global playstream
    try:
        playstream = subprocess.Popen(psa,
                    stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                        shell=False)
    except:
        print(Fore.RED + "Track Sync Failed!")
        clean_exit()

    # Create a UDS socket
    global sock
    sock = createUDS(udsock)

    # send the URL and start
    sendPlaybackURL(stream_url)
    startPlay()

def getkey():
    old_settings = termios.tcgetattr(sys.stdin)
    tty.setcbreak(sys.stdin.fileno())
    try:
        while True:
            b = os.read(sys.stdin.fileno(), 3).decode()
            if len(b) == 3:
                k = ord(b[2])
            else:
                k = ord(b)
            key_mapping = {
                127: 'backspace',
                10: 'return',
                32: 'space',
                9: 'tab',
                27: 'esc',
                65: 'up',
                66: 'down',
                67: 'right',
                68: 'left',
                49: 'home',
                52: 'end',
                53: 'pgup',
                54: 'pgdown',
            }
            return key_mapping.get(k, chr(k))
    finally:
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)

def skipper():
    global playlist
    trackRated = None
    while True:
        k = getkey()
        if k == '?':
            # debugging - dump playlist
            sockSendCmds(["get_property", "playlist"], mpvRequestID.PLAYLIST.value)
        elif k == 'q':
            # Re-enable cursor if it was turned off
            print('\033[?25h')
            print(Fore.RED + "Shutting down...")
            print_stop_time()
            break
        elif k == 'up':
            track = getPlayingTrack()
            if track != trackRated:
                trackRated = track
                print(f"{Fore.RED} ♥", end="")
                sys.stdout.flush()
                sendTrackLove(track)
        elif k == 'down':
            track = getPlayingTrack()
            if track != trackRated:
                trackRated = track
                print(f"{Fore.RED} ⛔", end="")
                sys.stdout.flush()
                sendTrackWTF(track)

    clean_exit()

# Handle arguments
parser = argparse.ArgumentParser(description='Simple Python 3 player for SomaFM, version ' + version)
parser.add_argument('-l', '--list', action='store_true', help='Download and display list of channels')
parser.add_argument('-s', '--stats', action='store_true', help='Display current listener stats')
parser.add_argument('-a', '--about', action='store_true', help='Show information about SomaFM')
parser.add_argument('-c', '--cast', nargs='?', default=False, help='Start playback on Chromecast')
parser.add_argument('-f', '--file', action='store_true', help='Enable experimental track logging for this session')
parser.add_argument('-v', '--verbose', action='store_true', help='For debug use, prints all events from mpv.')
parser.add_argument('-r', '--random', action='store_true', help='Choose a random channel at startup')
parser.add_argument('-ao', '--audio', nargs='?', metavar='audio-device', default='alsa/pipewire', help='Audio device to use [default alsa/pipewire], use "help" to list available devices')
parser.add_argument("channel", nargs='?', const=1, default=None, help="Channel to stream. Default is Drone Zone (unless the --random flag is passed)")
args = parser.parse_args()

# None means user gave -c option, but no device name
if args.cast is None:
    args.cast = True
else:
    # If there is string after -c, use it as device name
    chromecast_name = args.cast

# Enable log file
if args.file:
    log_tracks = True

# check if we were trying to list audio devices
if args.audio == "help":
    devices = subprocess.run(['mpv', '--audio-device=help'], stdout=subprocess.PIPE).stdout.decode('utf-8')
    print(devices)
    clean_exit()

# Get screen ready
colorama.init()
print(Style.BRIGHT, end='')

if args.about:
    # I can't decide which one I like best, so let's use them all!
    randlogo = randrange(3)
    if randlogo == 0:
        print(Fore.BLUE + r"   _____                  " + Fore.GREEN + r"     ________  ___")
        print(Fore.BLUE + r"  / ___/____  ____ ___  ____ _" + Fore.GREEN + r"/ ____/  |/  /")
        print(Fore.BLUE + r"  \__ \/ __ \/ __ `__ \/ __ `" + Fore.GREEN + r"/ /_  / /|_/ / ")
        print(Fore.BLUE + r" ___/ / /_/ / / / / / / /_/ " + Fore.GREEN + r"/ __/ / /  / /  ")
        print(Fore.BLUE + r"/____/\____/_/ /_/ /_/\__,_" + Fore.GREEN + r"/_/   /_/  /_/   ")
    elif randlogo == 1:
        print(Fore.BLUE + r" __" + Fore.GREEN + r"                         ___")
        print(Fore.BLUE + r"/ _\ ___  _ __ ___   __ _  " + Fore.GREEN + r"/ __\/\/\   ")
        print(Fore.BLUE + r"\ \ / _ \| '_ ` _ \ / _` |" + Fore.GREEN + r"/ _\ /    \  ")
        print(Fore.BLUE + r"_\ \ (_) | | | | | | (_| " + Fore.GREEN + r"/ /  / /\/\ \ ")
        print(Fore.BLUE + r"\__/\___/|_| |_| |_|\__,_" + Fore.GREEN + r"\/   \/    \/ ")
    elif randlogo == 2:
        print(Fore.BLUE + r" ______     ______     __    __     ______  " + Fore.GREEN + r"   ______   __    __    ")
        print(Fore.BLUE + r"/\  ___\   /\  __ \   /\ '-./  \   /\  __ \ " + Fore.GREEN + r"  /\  ___\ /\ '-./  \   ")
        print(Fore.BLUE + r"\ \___  \  \ \ \/\ \  \ \ \-./\ \  \ \  __ \ " + Fore.GREEN + r" \ \  __\ \ \ \-./\ \  ")
        print(Fore.BLUE + r" \/\_____\  \ \_____\  \ \_\ \ \_\  \ \_\ \_\ " + Fore.GREEN + r" \ \_\    \ \_\ \ \_\ ")
        print(Fore.BLUE + r"  \/_____/   \/_____/   \/_/  \/_/   \/_/\/_/ " + Fore.GREEN + r"  \/_/     \/_/  \/_/ ")

    print(Fore.WHITE + "")
    print("SomaFM is a listener-supported Internet-only radio station.")
    print("")
    print("That means no advertising or annoying commercial interruptions. SomaFM's")
    print("mission is to search for and expose great new music which people may")
    print("otherwise never encounter.")
    print("")
    print("If you like what you hear on SomaFM and want to help, please consider")
    print("visiting their site and making a donation.")
    print("")
    print(Fore.BLUE + "https://somafm.com/support/")
    print("")
    clean_exit()

# declare the device
if not args.cast:
    print("Using audio device: " + args.audio)

# get channel list
downloadChannels()

if args.list:
    listChannels()
    clean_exit()

if args.stats:
    showStats()
    clean_exit()

# Open file for track logging (enable line buffering)
if log_tracks:
    track_log = open(track_file, 'a', 1)

# If -r option given and no channel provided, pick random channel from list
if args.random and args.channel == None:
    args.channel = choice([chan['title'] for chan in channel_list])
elif args.channel == None:
    args.channel = default_chan

# Record the start time
start_time = datetime.now()

# Load signal handler
signal.signal(signal.SIGINT, signal_handler)

# launch keyboard monitor for skipper
#   daemon means it will be killed when main thread exits
t = Thread(target=skipper, daemon=True)
t.start()


# If Chromecast support is enabled, break off here
if args.cast:
    if chromecast_support:
        startCast(args.channel)
    else:
        print(Fore.RED + "Chromecast Support Disabled!")
        print(Fore.WHITE + "Please install the pychromecast library.")
        clean_exit()
else:
    # Else, playback stream
    startStream(args.channel)

# Before we can request full metadata, we need the load to complete:
#   not just file-loaded but playback-restart
ready = False
while sock is not None and not ready:
    try:
        events = sock.recv(4096)
        events = events.decode('utf8')
        for eventRaw in events.splitlines():
            event = json.loads(eventRaw)
            if args.verbose:
                print(eventRaw)
            if "event" in event and event["event"] == "playback-restart":
                ready = True
    except socket.error as e:
        clean_exit()

# request metadata and codec
sockSendCmds(["get_property", "metadata"], mpvRequestID.METADATA.value)
sockSendCmds(["get_property", "audio-codec-name"], mpvRequestID.CODEC.value)
sockSendCmds(["get_property", "audio-out-params"], mpvRequestID.PARAMS.value)
sockSendCmds(["get_property", "audio-bitrate"], mpvRequestID.BITRATE.value)

# Hide cursor
print('\033[?25l', end="")
while sock is not None:
    lastTrack = None
    try:
        events = sock.recv(4096)
        events = events.decode('utf8')
        for eventRaw in events.splitlines():
            event = json.loads(eventRaw)
            if args.verbose:
                print(event)
            if "file_error" in event and event["file_error"] == "audio output initialization failed":
                print(f"\n{Fore.RED}ERROR: failed to initialize audio driver {args.audio}")
                clean_exit()
            elif "file_error" in event and event["file_error"] == "loading failed":
                print(f"{Fore.RED}.", end="")
                sys.stdout.flush()
            elif "data" in event and "request_id" in event and event["request_id"] == mpvRequestID.METADATA.value:
                if "icy-name" in event['data']:
                    print(f"{Fore.CYAN}Channel: {Fore.WHITE}{event['data']['icy-name']}")
                if "icy-genre" in event['data']:
                    print(f"{Fore.CYAN}Genre: {Fore.WHITE}{event['data']['icy-genre']}")
            elif "data" in event and "request_id" in event and event["request_id"] == mpvRequestID.PARAMS.value:
                print(f"{Fore.CYAN}Audio: {Fore.WHITE}{event['data']['samplerate']}Hz {event['data']['hr-channels']} {event['data']['format']}")
            elif "data" in event and "request_id" in event and event["request_id"] == mpvRequestID.CODEC.value:
                print(f'{Fore.CYAN}Codec: {Fore.WHITE}{event["data"]}')
            elif "request_id" in event and event["request_id"] == mpvRequestID.BITRATE.value:
                if event["error"] == "success":
                    print(f"{Fore.CYAN}Bitrate: {Fore.WHITE}~{event['data'] // 1000} Kbps")
                else:
                    # not valid yet, try again
                    time.sleep(.1)
                    sockSendCmds(["get_property", "audio-bitrate"], mpvRequestID.BITRATE.value)
            elif "event" in event and event["event"] == "metadata-update":
                # rather than requesting media-title, which may not be set with Rusty's
                # high-quality HLS flac streaming, pull the complete info from the API
                # This allows us to also get the album name!  and we then set that back for
                # playerctl
                # request the new title
                track = getPlayingTrack()

                # there are situations where a metadata-update is sent, but track name proper
                # has not updated, such as interstitial station IDs
                # ignore dupes
                if track != lastTrack:
                    lastTrack = track
                    ## construct and print track name
                    # Print date before track
                    print("")
                    print(f'{Fore.BLUE}{datetime.now().strftime("%H:%M:%S")}', end=' | ')
                
                    print(f"{Fore.GREEN}{track['artist']} {Fore.WHITE}- {Fore.YELLOW}{track['title']} {Fore.MAGENTA}[{track['album']}]", end="")
                    sys.stdout.flush()

                    # Track for logging, notifications and metadata
                    track_desc = f"{track['artist']} - {track['title']} [{track['album']}]"

                    # update metadata for playerctl and friends
                    sockSendCmds(["set_property", "force-media-title", track_desc])

                    # Log track to file if enabled
                    if log_tracks:
                        track_log.write(track_desc + "\n")
                    # Run custom notification command if enabled
                    if custom_notifications:
                        subprocess.run([notification_cmd, track_desc], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=False)
            elif "data" in event and "request_id" in event and event["request_id"] == mpvRequestID.PLAYLIST.value:
                # show playlist
                print(f"{Fore.CYAN}\n\t--------------------------")
                pls = event['data']
                for ptrk in pls:
                    url = ptrk['filename']
                    if 'current' in ptrk and ptrk['current']:
                        pt = f"\t{Fore.YELLOW}→"
                    else:
                        pt = "\t "
                    print(f"{pt}{Fore.CYAN}{url}")
                print(f"{Fore.CYAN}\t--------------------------", end="")
                sys.stdout.flush()
    except socket.error as e:
        clean_exit()
