#!/usr/bin/env python3
# Python frontend for playing SomaFM with mpv
# by whorfin
# Licensed under the GPLv3, see "COPYING"
#   inspired by "somafm" by Tom Nardi (MS3FGX@gmail.com)
version = "2.7.11"

import re
import os
import sys
import socket
import signal
import requests
import argparse
import colorama
import subprocess
import time
from random import randrange, choice
from datetime import datetime
from colorama import Fore, Style

from threading import Thread, Lock
import tty,termios   # sys and os already imported
import uuid
import json

from enum import Enum

import html

# Optional Chromecast support, don't error if can't import
try:
    import pychromecast
    chromecast_support = True
except ImportError:
    chromecast_support = False

# Basic config options:
#-----------------------------------------------------------------------

# Default channel to play
default_chan = "Drone Zone"

# Name of Chromecast device
chromecast_name = "The Sound Pool"

# File to store track listing
track_file = "/tmp/somafm_tracks.txt"
apiBase = "https://api.somafm.com"  # no trailing slash please
apiTimeout = 5

## set up needed globals
sock = None

# create the locks we will need
socketLock = Lock()     # protect against thread races in socket usage

# to play along...  
# can send commands, ie {"command":["get_property","track-list"]} or {"command":["get_property","metadata"]}
#   unlike named pipes, each unix-domain socket connection gets its own session
# $ socat - /tmp/mpvsocket.UUID

# socket to use
udsock = f"/tmp/mpvsocket.{uuid.uuid1()}"

session = requests.Session()
session.headers.update({
    'User-Agent' : f'somafm/{version} (python; github.com/whorfin/SomaFM)',
    'Accept-Encoding' : 'gzip, deflate, br'
})

# global process handles
playstream = None
hlsstream = None
# global cast and stream handles if active
cast = None
stream = None

# enums to keep track of requests
class mpvRequestID(Enum):
    AO_DEVICE = 1
    PLAYLIST = 2
    METADATA = 3
    CODEC = 4
    PARAMS = 5
    BITRATE = 6
    METADATA_OBSERVE = 7

class Spinner:
    active = False
    i = 0

    def spin(self, color=None):
        cursor = '\\|/-'[self.i]
        self.i += 1
        self.i %= 3
        if not self.active:
            sys.stdout.write(' ')
            if color:
                sys.stdout.write(color)
            self.active = True
        sys.stdout.write(f'\b{cursor}')
        sys.stdout.flush()

    def spun(self):
        if self.active:
            sys.stdout.write(f'\b')
            sys.stdout.flush()
        # reset for next time, if there is a next time
        self.active = False
        self.i = 0

# sp is the subprocess whose UDS IPC we are attempting to connect to
def createUDS(udsock, sp):
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    print(f'Connecting to {udsock}', end="")
    sys.stdout.flush()
    # wait until mpv starts
    connected = False
    spinner = Spinner()
    while not connected:
        try:
            sock.connect(udsock)
            connected = True
        except:
            if sp.poll() is not None:
                print(f'{Fore.RED}FAILED')
                print(f'{Fore.RED}MPV returned {Fore.YELLOW}{sp.returncode}')
                clean_exit()

            spinner.spin()
            time.sleep(.1)
    spinner.spun()
    print(" ")
    return(sock)

# cmds is a list
def sockSendCmds(cmds, request_id=None):
    if sock is None:
        return
    # since we send this via JSON, mpv's input/ipc.c tells us we have to be careful to create
    #   valid json.  So let's use the real json parser to handle escaping
    #
    # build the json for the list of cmds
    jcmds = {"command": cmds}
    if request_id is not None:
        jcmds.update({"request_id": request_id})

    # serialize and transmit
    strcmds = json.dumps(jcmds)
    with socketLock:
        try:
            sock.sendall(f'{strcmds}\n'.encode('utf-8'))
        except socket.error as e:
            print(f'{Fore.RED}sockSendCmds: Error communicating with mpv:{e}')

def sockReceive():
    if sock is None:
        return
    events = sock.recv(64*1024)
    return(events.decode('utf8'))

# if we send tracks with "append-play", first track's force-media-title may not work
#   so once we've got the playlist set, we need to start playback
def sendPlaybackURL(url):
    sockSendCmds(["loadfile", url, "append"])

def startPlay():
    sockSendCmds(["playlist-play-index", 0])

def print_stop_time():
    # Calculate how long we were playing
    time_elapsed = datetime.now() - start_time
    hours, remainder = divmod(int(time_elapsed.total_seconds()), 3600)
    minutes, seconds = divmod(remainder, 60)

    # Print exit message
    print('\033[?25h')
    print(f'{Fore.RESET}Playback stopped after {int(hours):02}:{int(minutes):02}:{int(seconds):02}')

# Catch ctrl-c
def signal_handler(sig, frame):
    # Re-enable cursor if it was turned off
    print('\033[?25h')
    print(f'{Fore.RED}Force closing...')
    print_stop_time()
    clean_exit()

# Do any necessary cleanup when closing on good terms
termSettings = termios.tcgetattr(sys.stdin)
def clean_exit():
    # Re-enable cursor if it was turned off
    print('\033[?25h')

    global sock
    if sock is not None:
        sockSendCmds(["quit"])
        sock = None
    global playstream
    if playstream:
        playstream.terminate()  # just in case, and especially w/ audio error loop
        playstream = None
    global hlsstream
    if hlsstream:
        hlsstream.terminate()  # just in case, and especially w/ audio error loop
        hlsstream = None
    global stream
    if stream:
        # stop playback and shut down cast app, back to ambient mode if enabled
        stream.stop()
        cast.quit_app()
    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, termSettings)
    try:
        os.unlink(udsock)
    except OSError:
        pass

    # Close log file
    if args.file:
        track_log.close()
    sys.exit(0)

# launch IPC-controlled, headless mpv
# returns subprocess
clientName = "SomaFM"
def launchMPV(loopPlaylist = True, useAudio = True, directURL = None):
    # when using playlists, loop over the playlist to handle server oopses
    # or network issues; "force" re-evaluates each entry for validity each time 
    # through rather than caching the [possibly temporary] busted status
    #
    # The caching stuff here looks a little weird but ensures a 4s buffer
    #   somafm allows fast download of approx 8 seconds, then it is "realtime"
    #   (so we debugged with a 10sec cache setting)
    # Adding "--demuxer-cache-wait=yes" won't start until cache is full (and is 
    #   supposed to have no further influence during runtime), otherwise
    #   this combo of flags (which oddly requires cache-pause-initial though it 
    #   doesn't wait) will set things up to maintain a 4 second cache, reading
    #   more if needed even while playing
    cacheSecs = 4
    psa = ['mpv']
    psa += ['--no-video',
            '--no-ytdl',
            '--keep-open=no'       # commonly overridden
            ]
    if loopPlaylist:
        psa += ['--loop-playlist=force' ]

    # demuxer uses approx 520KiB for 4sec 48Khz stereo s16 FLAC
    # default allows 150MiB; demuxer settings here just for safety
    #   NOTE - setting demux-max-back-bytes to zero seems to interfere 
    #   with metadata update detection in the stream
    psa += ['--cache=yes',
            f'--cache-secs={cacheSecs}',
            '--demuxer-max-bytes=1MiB',
            '--demuxer-max-back-bytes=16KiB',
            '--demuxer-donate-buffer=no'
            ]
    if useAudio:
        psa += [f'--audio-device={args.audio}']
        psa += [f'--audio-client-name={clientName}']
    else:
        psa += ["--audio-device=null"]
    psa += ['--network-timeout=30']

    # basically headless; can't use --no-config as we need global plugins particularly mpv-mpris
    psa += ["--no-terminal"]
    psa += ["--no-osc"]
    psa += ["--no-input-default-bindings"]
    psa += ["--no-input-builtin-bindings"]
    psa += ["--load-osd-console=no"]
    #psa += ["--load-scripts=no"]   # this also prevents mpv-mpris from working
    psa += ["--load-stats-overlay=no"]
    # finally...
    if not directURL:
        # start with IPC enabled, idling
        psa += [f"--input-ipc-server={udsock}"]
        psa += ["--idle"]
    else:
        # start as essentially an uncontrolled daemon, directly playing
        psa += [directURL]

    try:
        sp = subprocess.Popen(psa,
                    stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                    shell=False)
    except:
        print(f'{Fore.RED}FAILED')
        print(f'{Fore.WHITE}Encountered an unknown error launching MPV.')
        clean_exit()

    return(sp)

# Download master list of channels
def downloadChannels():
    global channel_list

    print("Downloading channel list...", end='')
    sys.stdout.flush()

    try:
        channel_raw = session.get(f"{apiBase}/channels.json", timeout=apiTimeout)
    except requests.exceptions.Timeout:
        print("Timeout!")
        clean_exit()
    except requests.exceptions.ConnectionError:
        print("Network Error!")
        clean_exit()
    except requests.exceptions.RequestException as e:
        print("Unknown Error!")
        clean_exit()

    channel_list = channel_raw.json()['channels']

    # sort it
    channel_list.sort(key=lambda x: x['id'].lower())

    print("OK")

# Loop through channels and print their descriptions
def listChannels():

    # Find longest channel name
    channel_length = max(len(channel['title']) for channel in channel_list)

    # Loop through channels
    print(f'{Fore.RED}------------------------------')
    for channel in channel_list:
        # Adjust spacing to fit longest channel name
        print(f'{Fore.BLUE}{channel["title"]:>{channel_length}}{Fore.WHITE}', end=' : ')
        print(f'{Fore.GREEN}{channel["description"]}{Fore.RESET}')

# Show sorted list of listeners
def showStats():
    # To count total listeners
    listeners = 0

    # mini list for listener sorting
    listener_list = []

    # Put channels and listener counts into list
    for channel in channel_list:
        listener_list.append([channel['title'], int(channel['listeners'])])

    # Sort and print results
    listener_list.sort(key=lambda x: x[1], reverse=True)
    print(f'{Fore.RED}------------------------------')
    for key, val in listener_list:
        # Total up listeners
        listeners = listeners + val
        print(f'{Fore.GREEN}{val:>4}{Fore.BLUE}', end=' : ')
        print(f'{Fore.BLUE}{key}{Fore.RESET}')

    # Print total line
    print(f'{Fore.YELLOW}{listeners:>4}{Fore.BLUE}', end=' : ')
    print(f'{Fore.CYAN}Total Listeners{Fore.RESET}')

# Return information for given channel
def channelGet(request, channel_name):
    for channel in channel_list:
        if channel_name.lower() in channel['title'].lower():
            # Channel exists, now what?
            if request == "VERIFY":
                return()
            elif request == "PLS":
                # Return a tuple; if second entry is not None, it's an HLS link,
                #   and the regular stream link is the lowest quality
                #   icecast stream - for title change detection on HLS streams

                # the first one isn't necessarily the best; "quality_num" was just the nth, 
                # but they have names! and aren't necessarily ordered by quality; mp3 comes 
                # before aac now
                #   we want "highest" and 'aac' if we can get it [should always be true]
                #return(channel['playlists'][0]['url'])

                #print(channel['playlists'])
                if "hlsPlaylists" in channel:
                    for hpls in channel['hlsPlaylists']:
                        if hpls['quality'] == "lossless":
                            url = hpls['url']
                            if hpls['format'] == "flac-fmp4":
                                for pls in channel['playlists']:
                                    if pls['quality'] == "low":
                                        url = pls['url']
                                        return((pls['url'], hpls['url']))
                url = None
                fmt = None
                for pls in channel['playlists']:
                    if pls['quality'] == "highest":
                        url = pls['url']
                        fmt = pls['format']
                        if fmt == "aac":
                            return((pls['url'], None))
                if url != None:
                    print(f"{Fore.RED}Could not find AAC stream, settling for {fmt}{Fore.WHITE}")
                    return((url, None))
                print(f"{Fore.RED}No 'highest' quality stream found, bailing{Fore.WHITE}")
                clean_exit()
            elif request == "NAME":
                return(channel['title'])
            elif request == "DESC":
                return(channel['description'])
            elif request == "ICON_URL":
                return(channel['xlimage'])
            elif request == "STID":
                return(channel['id'])
            elif request == "URL":
                # parse this out directly, we only want one format; AAC FTW
                url = None
                fmt = None
                for pls in channel['playlists']:
                    #print(pls)
                    if pls['quality'] == "highest":
                        fmt = pls['format']
                        if fmt == "aac":
                            url = pls['url']
                            break
                if url == None:
                    print(f'{Fore.RED}No "highest" quality AAC stream found, bailing')
                    clean_exit()

                pls_file = session.get(url, timeout=apiTimeout)
                # Split out file URL
                for line in pls_file.text.splitlines():
                    if "File1" in line:
                        return(line.split('=')[1])
            else:
                print(f'{Fore.RED}Unknown channel operation!')
                clean_exit()

    # If we get here, no match
    print(f'{Fore.RED}Channel not found!')
    print(f'{Fore.WHITE}Double check the name of the channel and try again.')
    clean_exit()

# Stream channel with media player
def startStream(channel_name):
    # Verify stream exists before starting stream
    (stream_link, hlsLink) = channelGet('PLS', args.channel)   # mpv wants PLS
    if hlsLink is not None:
        print(f"{Fore.GREEN}Good news, everyone!  Lossless stream found.{Fore.WHITE}")
        # because the HLS lossless tream is currently quite ahead of the low-quality icecast
        print(f"\t{Fore.GREEN}Note that track titles will be delayed{Fore.WHITE}")

    # launch mpv, for either playback or track listing
    global playstream
    playstream = launchMPV(useAudio = hlsLink is None)
    print("Launched mpv")

    global sock
    sock = createUDS(udsock, playstream)

    if hlsLink is not None:
        # start totally headless HLS playback
        global hlsstream
        hlsstream = launchMPV(directURL = hlsLink)

    print(f'{Fore.RED}----------------------------------------------------------------------')
    print(f'{Fore.WHITE}<Up> to Love a Track, <Down> to WTF?! a Track')
    print(f'{Fore.WHITE}<q> to Quit')
    print(f'{Fore.RED}----------------------------------------------------------------------')

    # send the URL and start
    sendPlaybackURL(stream_link)
    startPlay()


def getPlayingTrack():
    stid = channelGet('STID', args.channel)
    songsr = session.get(f"{apiBase}/songs/{stid}.json", timeout=apiTimeout)
    songs = songsr.json()
    track = songs["songs"][0]
    return(track)

# the "device=(null)" was presumably because iOS no longer allows [easily] deviceid; drop it
#   Rusty asked for a "client=" to be set, so we do so
def createRatePayload(channel, track):
    stid = channelGet('STID', channel)
    payload = {'channel' : stid,
                   'artist' : track['artist'],
                   'title' : track['title'],
                   'client' : "somafm(python)",
                   'lang' : 'en-US'
                   }
    return(payload)

def sendTrackLove(track):
    ratePayload = createRatePayload(args.channel, track)
    rateRaw = session.get(f"{apiBase}/songlove.cgi", params=ratePayload, timeout=apiTimeout)
    # rateRaw.text should be 'OK\n'

def sendTrackWTF(track):
    ratePayload = createRatePayload(args.channel, track)
    rateRaw = session.get(f"{apiBase}/songwtf.cgi", params=ratePayload, timeout=apiTimeout)
    # rateRaw.text should be 'OK\n'


# Stream channel on Chromecast
def startCast(channel_name):
    # Populate stream variables
    stream_name = channelGet('NAME', channel_name)
    stream_url = channelGet('URL', channel_name)
    icon_url = channelGet('ICON_URL', channel_name)

    # Now try to communicate with CC
    print("Connecting to", chromecast_name, end='...')
    sys.stdout.flush()
    chromecasts, browser = pychromecast.get_listed_chromecasts(friendly_names=[chromecast_name])
    if not chromecasts:
        print(f'{Fore.RED}FAILED')
        print(f'{Fore.WHITE}No chromecast with name "{chromecast_name}" discovered')
        clean_exit()
    global cast
    cast = chromecasts[0]

    # Attempt to start stream
    global stream
    try:
        # Start socket client's worker thread and wait for initial status update
        cast.wait()
        stream = cast.media_controller
        stream.play_media(stream_url, 'audio/aac', stream_name, icon_url)
        stream.block_until_active()
    except:
        print(f'{Fore.RED}FAILED')
        print(f'{Fore.WHITE}Stream failed to start on Chromecast.')
        clean_exit()
    print("OK")

    browser.stop_discovery()

    # Start player with no audio to get track info
    global playstream
    playstream = launchMPV(useAudio = False)

    # Create a UDS socket
    global sock
    sock = createUDS(udsock, playstream)

    # send the URL and start
    sendPlaybackURL(stream_url)
    startPlay()

def getkey():
    old_settings = termios.tcgetattr(sys.stdin)
    tty.setcbreak(sys.stdin.fileno())
    try:
        while True:
            b = os.read(sys.stdin.fileno(), 3).decode()
            if len(b) == 3:
                k = ord(b[2])
            else:
                k = ord(b)
            key_mapping = {
                127: 'backspace',
                10: 'return',
                32: 'space',
                9: 'tab',
                27: 'esc',
                65: 'up',
                66: 'down',
                67: 'right',
                68: 'left',
                49: 'home',
                52: 'end',
                53: 'pgup',
                54: 'pgdown',
            }
            return key_mapping.get(k, chr(k))
    finally:
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)

def skipper():
    global playlist
    trackRated = None
    while True:
        k = getkey()
        if k == '?':
            # debugging - dump playlist
            sockSendCmds(["get_property", "playlist"], mpvRequestID.PLAYLIST.value)
        elif k == 'q':
            # Re-enable cursor if it was turned off
            print('\033[?25h')
            print(f'{Fore.RED}Shutting down...')
            print_stop_time()
            break
        elif k == 'up':
            track = getPlayingTrack()
            if track != trackRated:
                trackRated = track
                print(f"{Fore.RED} ♥", end="")
                sys.stdout.flush()
                sendTrackLove(track)
        elif k == 'down':
            track = getPlayingTrack()
            if track != trackRated:
                trackRated = track
                print(f"{Fore.RED} ⛔", end="")
                sys.stdout.flush()
                sendTrackWTF(track)

    clean_exit()

# Handle arguments
parser = argparse.ArgumentParser(description='Simple Python 3 player for SomaFM, version ' + version)
parser.add_argument('-l', '--list', action='store_true', help='Download and display list of channels')
parser.add_argument('-s', '--stats', action='store_true', help='Display current listener stats')
parser.add_argument('-a', '--about', action='store_true', help='Show information about SomaFM')
parser.add_argument('-c', '--cast', nargs='?', default=False, help='Start playback on Chromecast')
parser.add_argument('-f', '--file', action='store_true', help='Enable experimental track logging for this session')
parser.add_argument('-v', '--verbose', action='store_true', help='For debug use, prints all events from mpv.')
parser.add_argument('-r', '--random', action='store_true', help='Choose a random channel at startup')
parser.add_argument('-ao', '--audio', nargs='?', metavar='audio-device', default='auto', help='Audio device to use [default auto], use "help" to list available devices')
parser.add_argument("channel", nargs='?', const=1, default=None, help="Channel to stream. Default is Drone Zone (unless the --random flag is passed)")
args = parser.parse_args()

# None means user gave -c option, but no device name
if args.cast is None:
    args.cast = True
else:
    # If there is string after -c, use it as device name
    chromecast_name = args.cast

# check if we were trying to list audio devices
if args.audio == "help":
    devices = subprocess.run(['mpv', '--audio-device=help'], stdout=subprocess.PIPE).stdout.decode('utf-8')
    print(devices)
    clean_exit()

# Get screen ready
colorama.init()
print(Style.BRIGHT, end='')

if args.about:
    # I can't decide which one I like best, so let's use them all!
    randlogo = randrange(3)
    if randlogo == 0:
        print(rf"{Fore.BLUE}   _____                  {Fore.GREEN}     ________  ___")
        print(rf"{Fore.BLUE}  / ___/____  ____ ___  ____ _{Fore.GREEN}/ ____/  |/  /")
        print(rf"{Fore.BLUE}  \__ \/ __ \/ __ `__ \/ __ `{Fore.GREEN}/ /_  / /|_/ / ")
        print(rf"{Fore.BLUE} ___/ / /_/ / / / / / / /_/ {Fore.GREEN}/ __/ / /  / /  ")
        print(rf"{Fore.BLUE}/____/\____/_/ /_/ /_/\__,_{Fore.GREEN}/_/   /_/  /_/   ")
    elif randlogo == 1:
        print(rf"{Fore.BLUE} __{Fore.GREEN}                         ___")
        print(rf"{Fore.BLUE}/ _\ ___  _ __ ___   __ _  {Fore.GREEN}/ __\/\/\   ")
        print(rf"{Fore.BLUE}\ \ / _ \| '_ ` _ \ / _` |{Fore.GREEN}/ _\ /    \  ")
        print(rf"{Fore.BLUE}_\ \ (_) | | | | | | (_| {Fore.GREEN}/ /  / /\/\ \ ")
        print(rf"{Fore.BLUE}\__/\___/|_| |_| |_|\__,_{Fore.GREEN}\/   \/    \/ ")
    elif randlogo == 2:
        print(rf"{Fore.BLUE} ______     ______     __    __     ______  {Fore.GREEN}   ______   __    __    ")
        print(rf"{Fore.BLUE}/\  ___\   /\  __ \   /\ '-./  \   /\  __ \ {Fore.GREEN}  /\  ___\ /\ '-./  \   ")
        print(rf"{Fore.BLUE}\ \___  \  \ \ \/\ \  \ \ \-./\ \  \ \  __ \ {Fore.GREEN} \ \  __\ \ \ \-./\ \  ")
        print(rf"{Fore.BLUE} \/\_____\  \ \_____\  \ \_\ \ \_\  \ \_\ \_\ {Fore.GREEN} \ \_\    \ \_\ \ \_\ ")
        print(rf"{Fore.BLUE}  \/_____/   \/_____/   \/_/  \/_/   \/_/\/_/ {Fore.GREEN}  \/_/     \/_/  \/_/ ")

    print(f'{Fore.WHITE}')
    print("SomaFM is a listener-supported Internet-only radio station.")
    print("")
    print("That means no advertising or annoying commercial interruptions. SomaFM's")
    print("mission is to search for and expose great new music which people may")
    print("otherwise never encounter.")
    print("")
    print("If you like what you hear on SomaFM and want to help, please consider")
    print("visiting their site and making a donation.")
    print("")
    print(f'{Fore.BLUE}https://somafm.com/support/')
    print("")
    clean_exit()

# declare the device
if not args.cast:
    print("Using audio device: " + args.audio)

# get channel list
downloadChannels()

if args.list:
    listChannels()
    clean_exit()

if args.stats:
    showStats()
    clean_exit()

# Open file for track logging (enable line buffering)
if args.file:
    track_log = open(track_file, 'a', 1)

# If -r option given and no channel provided, pick random channel from list
if args.random and args.channel == None:
    args.channel = choice([chan['title'] for chan in channel_list])
elif args.channel == None:
    args.channel = default_chan

# Record the start time
start_time = datetime.now()

# Load signal handler
signal.signal(signal.SIGINT, signal_handler)

# launch keyboard monitor for skipper
#   daemon means it will be killed when main thread exits
t = Thread(target=skipper, daemon=True)
t.start()


# If Chromecast support is enabled and requested, do it
if args.cast:
    if chromecast_support:
        startCast(args.channel)
    else:
        print(f'{Fore.RED}Chromecast Support Disabled!')
        print(f'{Fore.WHITE}Please install the pychromecast library.')
        clean_exit()
else:
    # Else, playback stream locally
    startStream(args.channel)

# playlist has been loaded and playback started
#   now we just loop through the messages

# Before we can request full metadata, we need the load to complete:
#   not just file-loaded but playback-restart
ready = False
while sock is not None and not ready:
    try:
        events = sockReceive()
        for eventRaw in events.splitlines():
            event = json.loads(eventRaw)
            if args.verbose:
                print(eventRaw)
            if "event" in event and event["event"] == "playback-restart":
                ready = True
    except socket.error as e:
        clean_exit()

# the "metadata-update" event is deprecated, so we create an observer
#   note the syntax is tricky - we pass the ID to the observe cmd directly; the requestid
#   if used would be for the observe_property call itself, not the property-change which
#   is fired, which has "id" instead of "request_id"
# note that media-title does not fire, the 'icy-title' in metadata is what changes
#   for regular icecast streams [non-HLS]
# we don't actually begin observing the property until after we've displayed the Bitrate
#sockSendCmds(["observe_property", mpvRequestID.METADATA_OBSERVE.value, "metadata"])

# This is particularly relevant when "auto" device selection is in effect
sockSendCmds(["get_property", "current-ao"], mpvRequestID.AO_DEVICE.value)

# request metadata and codec
sockSendCmds(["get_property", "metadata"], mpvRequestID.METADATA.value)
if not hlsstream:
    sockSendCmds(["get_property", "audio-codec-name"], mpvRequestID.CODEC.value)
    sockSendCmds(["get_property", "audio-out-params"], mpvRequestID.PARAMS.value)
    sockSendCmds(["get_property", "audio-bitrate"], mpvRequestID.BITRATE.value)

# Hide cursor
lastTrack = None
print('\033[?25l', end="")
spinner = Spinner()
while sock is not None:
    try:
        events = sockReceive()
        for eventRaw in events.splitlines():
            event = json.loads(eventRaw)
            if args.verbose:
                print(event)
            if "file_error" in event and event["file_error"] == "audio output initialization failed":
                print(f"\n{Fore.RED}ERROR: failed to initialize audio driver {args.audio}")
                clean_exit()
            elif "data" in event and "request_id" in event and event["request_id"] == mpvRequestID.AO_DEVICE.value:
                print(f"{Fore.MAGENTA}Audio Output Driver: {Fore.WHITE}{event['data']}")
            elif "file_error" in event and event["file_error"] == "loading failed":
                print(f"{Fore.RED}.", end="")
                sys.stdout.flush()
            elif "data" in event and "request_id" in event and event["request_id"] == mpvRequestID.METADATA.value:
                if "icy-name" in event['data']:
                    print(f"{Fore.CYAN}Channel: {Fore.WHITE}{event['data']['icy-name']}")
                if "icy-genre" in event['data']:
                    print(f"{Fore.CYAN}Genre: {Fore.WHITE}{event['data']['icy-genre']}")

                if hlsstream:   # our low-quality stream data is not requested
                    # hls playback right now is FLAC
                    print(f'{Fore.CYAN}Codec: {Fore.WHITE}flac')
                    # no bitrate compute lag, begin tracking title changes
                    sockSendCmds(["observe_property", mpvRequestID.METADATA_OBSERVE.value, "metadata"])
            elif "data" in event and "request_id" in event and event["request_id"] == mpvRequestID.PARAMS.value:
                print(f"{Fore.CYAN}Audio: {Fore.WHITE}{event['data']['samplerate']}Hz {event['data']['hr-channels']} {event['data']['format']}")
            elif "data" in event and "request_id" in event and event["request_id"] == mpvRequestID.CODEC.value:
                print(f'{Fore.CYAN}Codec: {Fore.WHITE}{event["data"]}')
            elif "request_id" in event and event["request_id"] == mpvRequestID.BITRATE.value:
                if event["error"] == "success":
                    spinner.spun()
                    print(f"{Fore.CYAN}Bitrate: {Fore.WHITE}~{round(event['data'] / 1000)} Kbps")
                    # begin tracking title changes
                    sockSendCmds(["observe_property", mpvRequestID.METADATA_OBSERVE.value, "metadata"])
                else:
                    # not valid yet, try again
                    spinner.spin(Fore.CYAN)
                    time.sleep(.1)
                    sockSendCmds(["get_property", "audio-bitrate"], mpvRequestID.BITRATE.value)
            elif "event" in event and event["event"] == "property-change" and event["id"] == mpvRequestID.METADATA_OBSERVE.value:
                # rather than using media-title, which may not be set with Rusty's
                # high-quality HLS flac streaming, pull the complete info from the API
                # This allows us to also get the album name!  and we then set that back for
                # playerctl
                # request the new title
                track = getPlayingTrack()

                # there are situations where a metadata-update is sent, but track name proper
                # has not updated, such as interstitial station IDs
                # ignore dupes
                if track != lastTrack:
                    lastTrack = track

                    ## construct and print track name
                    #   i've found a bunch of weird stuff, mostly unicode zero-width-spaces
                    #   so first let's unescape things
                    artist = html.unescape(track['artist'])
                    title = html.unescape(track['title'])
                    album = html.unescape(track['album'])
                    # Print date before track
                    print("")
                    print(f'{Fore.BLUE}{datetime.now().strftime("%H:%M:%S")}', end=' | ')
                
                    print(f"{Fore.GREEN}{artist} {Fore.WHITE}- {Fore.YELLOW}{title} {Fore.MAGENTA}[{album}]", end="")
                    sys.stdout.flush()

                    # Track for logging, notifications and metadata
                    track_desc = f"{artist} - {title} [{album}]"

                    # update metadata for playerctl and friends
                    sockSendCmds(["set_property", "force-media-title", track_desc])

                    # Log track to file if enabled
                    if args.file:
                        track_log.write(track_desc + "\n")
            elif "data" in event and "request_id" in event and event["request_id"] == mpvRequestID.PLAYLIST.value:
                # show playlist
                print(f"{Fore.CYAN}\n\t--------------------------")
                pls = event['data']
                for ptrk in pls:
                    url = ptrk['filename']
                    if 'current' in ptrk and ptrk['current']:
                        pt = f"\t{Fore.YELLOW}→"
                    else:
                        pt = "\t "
                    print(f"{pt}{Fore.CYAN}{url}")
                print(f"{Fore.CYAN}\t--------------------------", end="")
                sys.stdout.flush()
    except socket.error as e:
        print(f'{Fore.RED}Socket Error communicating with mpv:{e}')
        clean_exit()
